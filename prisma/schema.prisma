generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id             String   @id @default(cuid())
  githubId       Int      @unique
  username       String   @unique
  email          String?
  avatarUrl      String?
  installationId Int?     @unique
  // Campos legacy (se eliminarán después de migración)
  accessToken    String?
  refreshToken   String?
  tokenExpiresAt DateTime?
  // Fin campos legacy
  isAdmin        Boolean  @default(false)
  isBanned       Boolean  @default(false)
  bannedAt       DateTime?
  bannedReason   String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  lastLoginAt    DateTime @default(now())

  // Relaciones
  token          UserToken?
  repoOrder      RepoOrder?
  syncLogs       SyncLog[]
  orderSnapshots OrderSnapshot[]
  adminActions   AdminLog[] @relation("AdminActions")
  targetedBy     AdminLog[] @relation("TargetedUser")

  @@map("users")
}

model RepoOrder {
  id            String   @id @default(cuid())
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Orden de repos: JSON string de array de repo full names
  reposOrder    String   @default("[]")

  // Cuantos repos ordenar (0 = todos)
  topN          Int      @default(10)

  // Incluir repos privados en el ordenamiento
  includePrivate Boolean @default(true)

  // Configuracion de sync
  syncFrequency Int      @default(168)
  autoEnabled   Boolean  @default(true)

  // Estrategia de commits: "branch" o "revert"
  commitStrategy String  @default("revert")

  // Programación horaria avanzada
  preferredHour  Int?    // Hora preferida del día UTC (0-23), null = cualquier hora

  // Secret para el endpoint de sync (UUID)
  syncSecret String?

  // Lock para evitar syncs concurrentes
  lastSyncAt    DateTime?  // Última vez que se inició un sync

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@map("repo_orders")
}

model SyncLog {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  action    String
  status    String
  details   String?
  reposAffected String @default("[]")

  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@map("sync_logs")
}

model OrderSnapshot {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Orden de repos: JSON string de array de repo full names
  reposOrder String

  // Número de repos en el top
  topN       Int

  // Tipo de cambio: "manual" o "auto"
  changeType String   @default("manual")

  createdAt  DateTime @default(now())

  @@index([userId, createdAt])
  @@map("order_snapshots")
}

model UserToken {
  id           String    @id @default(cuid())
  userId       String    @unique
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken  String
  refreshToken String?
  expiresAt    DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@map("user_tokens")
}

model AdminLog {
  id           String   @id @default(cuid())
  adminId      String
  admin        User     @relation("AdminActions", fields: [adminId], references: [id], onDelete: Cascade)
  targetUserId String
  targetUser   User     @relation("TargetedUser", fields: [targetUserId], references: [id], onDelete: Cascade)
  action       String   // BAN, UNBAN, DELETE, WARN
  reason       String?
  details      String?
  createdAt    DateTime @default(now())

  @@index([adminId, createdAt])
  @@index([targetUserId, createdAt])
  @@map("admin_logs")
}
